from __future__ import annotations

import sys
import time
from dataclasses import dataclass
from multiprocessing import Pool
from typing import Generic, List, TypeVar, Union

if sys.version_info >= (3, 9):
    from collections.abc import Sequence, Iterable, Callable
else:
    from typing import Sequence, Iterable, Callable

import numpy as np
from numpy.typing import NDArray

from .models import Model, SimulationParams, StaticParameters, SignalInterpolator
from .options import Options
from .specification import Specification

_ET = TypeVar("_ET")

Sample = Union[Sequence[float], NDArray[np.int_], NDArray[np.float_]]
Samples = Union[
    Sequence[Sequence[float]],
    Sequence[NDArray[np.float_]],
    Sequence[NDArray[np.int_]],
    NDArray[np.float_],
    NDArray[np.float_],
]

SpecificationFactory = Callable[[Sample], Specification]
SpecificationOrFactory = Union[Specification, SpecificationFactory]


def _static_parameters(sample: Sample, options: Options) -> StaticParameters:
    return sample[0 : len(options.static_parameters)]  # type: ignore


def _signal_interpolators(sample: Sample, options: Options) -> List[SignalInterpolator]:
    start = len(options.static_parameters)
    interpolators: List[SignalInterpolator] = []

    for signal in options.signals:
        factory = signal.factory
        end = start + signal.control_points
        interpolators.append(factory.create(signal.interval.astuple(), sample[start:end]))  # type: ignore
        start = end

    return interpolators


def _specification(sample: Sample, specification: SpecificationOrFactory) -> Specification:
    if callable(specification):
        return specification(sample)

    return specification


def _simulation_params(sample: Sample, options: Options) -> SimulationParams:
    static_params = _static_parameters(sample, options)
    interpolators = _signal_interpolators(sample, options)

    return SimulationParams(static_params, interpolators, options.interval)


@dataclass(frozen=True)
class TimingData:
    """Storage class for execution durations of different PSY-TaLiRo components.

    The durations stored in this class are for a single evaluation.

    Attributes:
        model: Run time of model component
        specification: Run time of specification component
    """

    model: float
    specification: float

    @property
    def total(self) -> float:
        """The total duration of all components."""

        return self.model + self.specification


@dataclass(frozen=True)
class Evaluation(Generic[_ET]):
    """The result of applying the cost function to a sample.

    Attributes:
        cost: The result of using a specification to analyze the output of a model
        sample: The sample provided to the model
        extra: Additional data returned by the model
        timing: Execution durations of each component of the cost function
    """

    cost: float
    sample: Sample
    extra: _ET
    timing: TimingData


@dataclass(frozen=True)
class Thunk(Generic[_ET]):
    """Class which represents the deferred evaluation of the cost function.

    A Thunk contains all the necessary information to produce an Evaluation, but does not execute
    the computation until the evaluate method is called (lazy value).

    Attributes:
        sample: The sample generated by the optimizer that is provided to the model
        model: Model instance which represents the system
        specification: Specification instance which represents the requirement
        options: Configuration object that controls the behavior of the Model and Specification
    """

    sample: Sample
    model: Model[_ET]
    specification: Specification
    options: Options

    def evaluate(self) -> Evaluation[_ET]:
        """Evaluate the sample using the specification and model.

        The computation is the following pipeline:
            sample -> model.simulate(sample) -> specification.evaluate(model_result) -> cost

        Returns:
            An Evaluation instance representing the result of the computation pipeline.
        """

        simulation_params = _simulation_params(self.sample, self.options)
        model_start = time.perf_counter()
        model_result = self.model.simulate(simulation_params)
        model_stop = time.perf_counter()

        spec_start = time.perf_counter()
        cost = model_result.eval_using(self.specification)
        spec_stop = time.perf_counter()
        timing_data = TimingData(model_stop - model_start, spec_stop - spec_start)

        return Evaluation(cost, self.sample, model_result.extra, timing_data)


def _evaluate(thunk: Thunk[_ET]) -> Evaluation[_ET]:
    return thunk.evaluate()


class CostFn(Generic[_ET]):
    """Class which represents the composition of a Model and Specification.

    A Model is responsible for modeling the system and returning a trajectory given a sample, and a
    Specification is responsible for evaluating a system trajectory and returning a value which
    indicates its "goodness". Composing these two components produces a component which can produce
    "goodness" values given a sample.

    Attributes:
        model: Model instance which represents a system
        specification: Specification instance or factory which represents the requirement
        options: Configuration object that controls the behavior of the Model and Specification
        history: List of all evaluations produced by this instance
    """

    def __init__(self, model: Model[_ET], specification: SpecificationOrFactory, options: Options):
        self.model = model
        self.specification = specification
        self.options = options
        self.history: List[Evaluation[_ET]] = []

    def _thunks(self, samples: Samples) -> Iterable[Thunk[_ET]]:
        for sample in samples:
            specification = _specification(sample, self.specification)
            yield Thunk(sample, self.model, specification, self.options)

    def eval_sample(self, sample: Sample) -> float:
        """Compute the cost of a single sample.

        Args:
            sample: Sample to evaluate

        Returns:
            The sample cost
        """

        specification = _specification(sample, self.specification)
        thunk = Thunk(sample, self.model, specification, self.options)
        evaluation = thunk.evaluate()

        self.history.append(evaluation)

        return evaluation.cost

    def eval_samples(self, samples: Samples) -> List[float]:
        """Compute the cost of multiple samples sequentially.

        Args:
            samples: Samples to evaluate

        Returns:
            The cost for each sample
        """

        return [self.eval_sample(sample) for sample in samples]

    def eval_samples_parallel(self, samples: Samples, processes: int) -> List[float]:
        """Compute the cost of multiple samples in parallel.

        Args:
            samples: The samples to evaluate
            processes: Number of processes to use to evaluate the samples

        Returns:
            The cost for each sample.
        """

        with Pool(processes=processes) as pool:
            evaluations: List[Evaluation[_ET]] = pool.map(_evaluate, self._thunks(samples))

        costs = [evaluation.cost for evaluation in evaluations]

        self.history.extend(evaluations)

        return costs
