from __future__ import annotations

from abc import ABC, abstractmethod
from collections.abc import Iterable, Sequence
from typing import Generic, NewType, Protocol, TypeVar, Union, overload

import numpy as np
from numpy.typing import NDArray
from rtamt import StlDenseTimeSpecification, StlDiscreteTimeSpecification
from typing_extensions import TypeAlias

from .cost_func import Result
from .models import Trace

S = TypeVar("S", contravariant=True)
C = TypeVar("C", covariant=True)
E = TypeVar("E", covariant=True)


class Specification(Generic[S, C, E], ABC):
    """Class that represents a requirement to be evaluated using simulation data.

    A specification should accept the trajectories and timestamps generated by a model and return
    a value which represents the "goodness" of the model results with respect to some criteria.
    """

    @abstractmethod
    def evaluate(self, __trace: Trace[S]) -> Result[C, E]:
        """Evaluate trajectories and timestamps with respect to some requirement.

        Args:
            trajectories: Matrix of states where each row represents a state variable.
            timestamps: Vector of time values corresponding to each column of the trajectories
                        matrix.

        Returns:
            A value indicating the "goodness" of the trajectories according to the requirement.
        """
        ...


class StlSpecificationError(Exception):
    pass


_Times = NewType("_Times", NDArray[np.float64])
_States = NewType("_States", NDArray[np.float64])
_Parsed: TypeAlias = tuple[_Times, _States]


def _parse_times_states(times: Iterable[float], states: Iterable[Sequence[float]]) -> _Parsed:
    times_ = _Times(np.array(times, dtype=np.float64))
    states_ = _States(np.array(states, dtype=np.float64))

    if times_.ndim != 1:
        raise StlSpecificationError("Times must be a 1-D vector")

    if states_.ndim != 2:
        raise StlSpecificationError("States must be a 2-D matrix")

    if states_.shape[0] == times_.size:
        return (times_, states_.T)
    elif states_.shape[1] == times_.size:
        return (times_, states_)
    else:
        raise StlSpecificationError("States must have one dimension that maches times length")


PredicateName: TypeAlias = str
ColumnT: TypeAlias = int
PredicateColumnMap: TypeAlias = dict[PredicateName, ColumnT]


class StlSpecification(Specification[Sequence[float], float, None]):
    @abstractmethod
    def __init__(self, requirement: str, column_map: PredicateColumnMap):
        ...


class RTAMTDiscrete(StlSpecification):
    """STL logic specification that uses RTAMT discrete-time semantics to compute robustness.

    Attributes:
        phi: The specification requirement
        predicates: A set of Predicate(s) used in the requirement
    """

    def __init__(self, phi: str, column_map: PredicateColumnMap):
        if "time" in column_map:
            raise StlSpecificationError("'time' cannot be used as a predicate name for RTAMT")

        self.phi = phi
        self.column_map = column_map

    def evaluate(self, trace: Trace[Sequence[float]]) -> Result[float, None]:
        times, states = _parse_times_states(trace.times, trace.states)

        if times.size < 2:
            raise RuntimeError("timestamps must have at least two samples to evaluate")

        spec = StlDiscreteTimeSpecification()

        for name in self.column_map:
            spec.declare_var(name, "float")

        period = times[1] - times[0]

        spec.set_sampling_period(round(period, 2), "s", 0.1)
        spec.spec = self.phi
        spec.parse()

        traces = {"time": list(times)}

        for name, column in self.column_map.items():
            traces[name] = list(states[column])

        robustness = spec.evaluate(traces)
        cost = robustness[0][1]

        return Result(cost, None)


class RTAMTDense(StlSpecification):
    """STL logic specification that uses RTAMT dense-time semantics to compute robustness.

    Attributes:
        phi: The specification requirement
        predicates: A set of Predicate(s) used in the requirement
    """

    def __init__(self, phi: str, column_map: PredicateColumnMap):
        self.phi = phi
        self.column_map = column_map

    def evaluate(self, trace: Trace[Sequence[float]]) -> Result[float, None]:
        times, states = _parse_times_states(trace.times, trace.states)
        spec = StlDenseTimeSpecification()

        for name in self.column_map:
            spec.declare_var(name, "float")

        spec.spec = self.phi
        spec.parse()

        map_items = self.column_map.items()
        traces = [
            (name, np.array([times.tolist(), states[column]]).T.tolist())
            for name, column in map_items
        ]

        robustness = spec.evaluate(*traces)
        cost = robustness[0][1]

        return Result(cost, None)


class UserResultFunc(Protocol[S, C, E]):
    def __call__(self, trace: Trace[S]) -> Result[C, E]:
        ...


class UserCostFunc(Protocol[S, C]):
    def __call__(self, trace: Trace[S]) -> C:
        ...


class UserSpecification(Specification[S, C, Union[E, None]]):
    def __init__(self, func: UserResultFunc[S, C, E] | UserCostFunc[S, C]):
        self.func = func

    def evaluate(self, trace: Trace[S]) -> Result[C, E | None]:
        cost = self.func(trace)

        if isinstance(cost, Result):
            return cost

        return Result(cost, None)


class Decorator(Protocol):
    @overload
    def __call__(self, __f: UserResultFunc[S, C, E]) -> Specification[S, C, E]:
        ...

    @overload
    def __call__(self, __f: UserCostFunc[S, C]) -> Specification[S, C, None]:
        ...


UserFunc: TypeAlias = Union[UserResultFunc[S, C, E], UserCostFunc[S, C]]
SpecificationOrDecorator: TypeAlias = Union[Specification[S, C, Union[E, None]], Decorator]

T = TypeVar("T")
U = TypeVar("U")
V = TypeVar("V")


@overload
def specification(func: UserResultFunc[S, C, E]) -> Specification[S, C, E]:
    ...


@overload
def specification(func: UserCostFunc[S, C]) -> Specification[S, C, None]:
    ...


@overload
def specification(func: None = ...) -> Decorator:
    ...


def specification(func: UserFunc[S, C, E] | None = None) -> SpecificationOrDecorator[S, C, E]:
    @overload
    def _decorator(f: UserResultFunc[T, U, V]) -> Specification[T, U, V]:
        ...

    @overload
    def _decorator(f: UserCostFunc[T, U]) -> Specification[T, U, None]:
        ...

    def _decorator(f: UserFunc[T, U, V]) -> Specification[T, U, V | None]:
        return UserSpecification(f)

    return _decorator(func) if func else _decorator
