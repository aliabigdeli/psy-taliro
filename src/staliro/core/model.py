from __future__ import annotations

from abc import ABC, abstractmethod
from typing import Any, Generic, Iterator, List, TypeVar, Union, overload

import numpy as np
from attr import Attribute, field, frozen
from numpy.core.shape_base import atleast_1d
from numpy.typing import NDArray

from .interval import Interval
from ..options import Options, SignalOptions
from .sample import Sample
from .signal import Signal

T = TypeVar("T")


@frozen(init=False)
class SystemInputs:
    """Representation of the inputs to the system under test (SUT).

    Decompose the sample generated by the optimizer into the time-invariant and time-varying inputs
    for the system.

    Args:
        sample: The sample generated by the optimizer
        options: The options provided by the user
    """

    static: List[float]
    signals: List[Signal]

    def __init__(self, sample: Sample, options: Options):
        def signal(it: Iterator[float], opts: SignalOptions) -> Signal:
            return opts.factory(opts.signal_times, [next(it) for _ in range(opts.control_points)])

        static_param_count = len(options.static_parameters)
        static_params = sample[0:static_param_count]
        signal_values_iter = iter(sample[static_param_count:])
        signals = [signal(signal_values_iter, sig_opts) for sig_opts in options.signals]

        object.__setattr__(self, "static", static_params)
        object.__setattr__(self, "signals", signals)


States = NDArray[np.float_]


def _states_converter(value: Any) -> States:
    return np.atleast_2d(np.array(value))


def _states_validator(obj: SystemData[Any], _: Attribute[Any], states: States) -> None:
    if not np.issubdtype(states.dtype, np.float_):
        raise TypeError()

    if states.ndim != 2:
        raise ValueError()

    if not any(dim == obj.times.shape[0] for dim in states.shape):
        raise ValueError()


Times = NDArray[np.float_]


def _times_converter(value: Any) -> Times:
    return atleast_1d(np.array(value))


def _times_validator(obj: Any, attr: Attribute[Any], times: Times) -> None:
    if not np.issubdtype(times.dtype, np.float_):
        raise TypeError()

    if times.ndim != 1:
        raise ValueError()


@frozen(init=False)
class SystemData(Generic[T]):
    _states: NDArray[np.float_] = field(validator=_states_validator, converter=_states_converter)
    times: Times = field(validator=_times_validator, converter=_times_converter)
    extra: T

    @overload
    def __init__(self: SystemData[None], states: Any, timestamps: Any):
        ...

    @overload
    def __init__(self, states: Any, timestamps: Any, extra: T):
        ...

    def __init__(self, states: Any, timestamps: Any, extra: T = None):
        self.__attrs_init__(states, timestamps, extra)  # type: ignore

    @property
    def states(self) -> States:
        if self._states.shape[0] == self.times.shape[0]:
            return self._states.T

        return self._states


@frozen(init=False)
class SystemFailure(Generic[T]):
    extra: T = field()

    @overload
    def __init__(self: SystemFailure[None]):
        ...

    @overload
    def __init__(self, extra: T):
        ...

    def __init__(self, extra: T = None):
        self.__attrs_init__(extra)  # type: ignore


SimulationResult = Union[SystemData[T], SystemFailure[T]]


class Model(Generic[T], ABC):
    @abstractmethod
    def simulate(self, inputs: SystemInputs, interval: Interval) -> SimulationResult[T]:
        ...
